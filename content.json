{"meta":{"title":"BTS500技术博客|比特股技术博客|比特股技术文档|比特股|Bitshares|BTS|比特币|以太坊|ETH|BTC","subtitle":"比特股技术文档整理，BTS技术交流。","description":"比特股技术文档整理。","author":"BTS500","url":"http://bts500.github.com"},"pages":[],"posts":[{"title":"Bitshares 开发者系列（2）—— Bitsharesjs-ws 库源码解读","slug":"Bitshares-开发者系列（2）——-Bitsharesjs-ws-库源码解读","date":"2018-03-12T02:52:56.000Z","updated":"2018-03-12T09:25:33.649Z","comments":true,"path":"2018/03/12/Bitshares-开发者系列（2）——-Bitsharesjs-ws-库源码解读/","link":"","permalink":"http://bts500.github.com/2018/03/12/Bitshares-开发者系列（2）——-Bitsharesjs-ws-库源码解读/","excerpt":"","text":"官方接口访问库 GitHub : https://github.com/bitshares/bitsharesjs-ws在阅读源码之前，最好先浏览一遍 Bitshares 官方公开的开发文档，虽然文档中对开发细节描述的不是很清楚，但也能对系统的通讯方式有个详细的了解。 项目库介绍 bitsharesjs-ws 是比特股的 Github 官方账号创建的一个项目，主要功能是提供一个访问比特股 API 节点的工具，与 API 节点通讯访问方式采用的是 WebSocket 方式，代码采用JS编写，可以同时运行于浏览器端与Node环境下。 项目代码结构如下：12345+ build * 编译版本的项目文件+ examples * 项目库的使用案例 + lib * 项目库源码文件+ test * 项目单元测试+ tools * 编译工具 直接进入 lib 目录，打开 index.js 文件阅读源码，你会发现项目库共导出三个如下模块：12345export &#123; Apis, // 工具库的主要接口，对外公开了 API 的访问方式，与节点服务器的通讯全部依赖此模块的内部实现 ChainConfig, // Bitshares 区块链公开的参数配置项 Manager // 与节点服务器之间的连接管理器，负责管理与检查和节点服务器之间的连接状态&#125; Apis 模块实现逻辑 Apis 模块对应的实现文件是 ApisInstances.js，该模块引入了 ChainWebSocket.js 、GrapheneApi.js 等内部模块，这些内部子模块的作用稍后再作描述，先看Apis模块导出的供外部系统调用的方法：123456789101112131415161718192021222324252627282930313233343536export default &#123; /** * String cs 代表要连接的完整钱包节点地址。 * Boolean connect 创建成功之后是否直接执行创建的对象的 connect 方法。 * int connectTimeout 连接节点时，响应超时的时间。 * Boolean enableCrypto 是否进行加密通讯。 * * @return 该方法会返回一个 ApiInstance 的实例对象，全局共享此单例对象。 */ instance (cs = \"ws://localhost:8090\", connect, connectTimeout = 4000, enableCrypto) /** * Function callback 设置一个当网络连接状态发生改变的时候的回调函数。 */ setRpcConnectionStatusCallback (callback) /** * 设定当网络连接失败的时候，是否自动重连，会重新设置 autoReconnect 的值。 */ setAutoReconnect (auto) /** * 重置当前的连接，假如当前是连接状态，会直接 */ reset (cs = \"ws://localhost:8090\", connect, connectTimeout = 4000) /** * 获取当前连接的服务器节点的区块链 ID */ chainId () /** * 关闭当前的连接 */ close ()&#125; 查看上面导出的方法实现，可以发现 instance 方法会构建一个 ApisInstance 对象的实例，并让外部系统该通过此实例调用对应类别的API接口，关于 ApisInstance 对象的定义如下：123456789101112131415161718192021222324Class ApiInstance &#123; chain_id // 当前连接的区块链 id String url // 当前连接的完整钱包节点地址。 statusCb ChainWebSocket ws_rpc // 创建的 ChainWebSocket 对象实例。 Promise init_promise GrapheneApi _db GrapheneApi _net GrapheneApi _hist GrapheneApi _crypt /** * 调用 instance() 的时候，第二个参数传递 true，会自动调用此函数连接区块节点，旨在初始化网络连接。 * 并且初始化 inst 内部的各个关键属性，init_promise, _db, ws_rpc ... */ connect (cs, connectTimeout, enableCrypto = false) close() db_api() network_api() history_api() crypto_api() setRpcConnectionStatusCallback()&#125; 此处方法的功能是与 Apis 模块提供的那些同名方法是相同的，因为 Apis 模块公开的那些方法，也是最终的中转到了此处的方法实现。重点需要注意的就是此对象的内部属性，主要有ws_rpc、init_promise、_db、_net、_hist、_crypt等。 ws_rpc 此属性的值是一个 ChainWebSocket 对象的实例，内部包装了 ReconnectWebSocket 对象，并定义了一套API接口的调用流程。最终由此对象向服务器节点发起 API 调用，并处理返回结果，这样一个完整的访问流程，就是此内部模块定义的。 init_promise 一个Promise对象，因为网络接口调用、WebSocket连接等操作都是异步响应的，所以此处定义了一个 Promise 对象来给外部系统使用，当与服务器节点之间的连接全部初始化完成之后，此异步对象就会变为完成状态。 _db _net _hist _crypt 这些属性都分别是一个 GrapheneApi 对象的实例，用于区分不同类别的API调用，因为 Bitshares 系统为不同的 API 接口设置有不同的 API 访问令牌，所以单独为每个 API 类型都创建了一个实例，以便外部系统调用不同类型的 API 的时候，不用反复设置 API 令牌标识。 关于 ChainWebSocket 与 ReconnectWebSocket 应该进一步解释下它们的作用，首先说一下 ReconnectWebSocket, ReconnectWebSocket 实现了在浏览器环境下的断线重连机制，因为整个模块是使用 WbeSocket 与服务节点进行通信连接的，所以可能会偶尔的发生 WebSocket 断开连接的问题。 因为当断开连接以后，可能就会导致订阅通知与API调用接口不能正常使用，这就需要外部系统自己再定义一套复杂的连接状态检查规则，来进行断线之后的连接与初始化操作。所以索性就在模块内部实现了一个 ReconnectWebSocket 模块，实现一套 Bitshares 系统专用的断线重连的制度，来保证与服务器节点连接的稳定性，减少外部系统的复杂程度，让外部系统能专心于业务逻辑的开发。 具体是如何定义重连制度的，可以自己查看 ReconnectWebSocket 模块的源码，这里不再详细介绍，但其实官方引用的 ReconnectWebSocket 在实现的时候也有一个问题，ReconnectWebSocket 仅仅是包装了 WebSocket 对象，并在内部依赖 document 与 window 对象，所以导致断线重连的制度在Nodejs的环境中是不可用的,只有在浏览器的环境下才会有断线重连保护。 ChainWebSocket 是建立在可靠的 ReconnectWebSocket 连接之上的，然后针对 Bitshares 系统的特性，构建了一个API的访问流程，和订阅通知的处理流程。外部系统的所有API操作操作都会经由 ChainWebSocket 处理并通过 WebSocket 发送到服务器节点，然后在响应结果发生以后，再由 ChainWebSocket 解析并转交给外外部系统处理。 由于在 Nodejs 的环境中是不存在 WebSocket 对象的，所以引入了一个开源的第三方 WebSocket 的实现 —— ws:1234567if (typeof WebSocket === \"undefined\" &amp;&amp; !process.env.browser) &#123; WebSocketClient = require(\"ws\");&#125; else if (typeof(WebSocket) !== \"undefined\" &amp;&amp; typeof document !== \"undefined\") &#123; WebSocketClient = require(\"ReconnectingWebSocket\")&#125; else &#123; WebSocketClient = WebSocket;&#125; 那么 Apis 模块的功能就已经全部介绍完了，梳理一下你的 API 访问流程应该是这样的: 通过 Apis.instance 连接操作，告诉模块要到的服务器节点，并且配置是否开启断线重连制度。 然后通过返回的 instance 对象属性 init_promise 来指定连接成功之后的下一步操作。 假如你在连接成功之后通过 instance.__db 属性调用了 get_account API，那么你的请求会经由 GrapheneApi 打上对应的API令牌标识，再投递给 ChainWebSocket 发送请求，当响应结果到来的时候，又会回调你的处理函数来完成一个完整的API请求流程。 Manager 模块实现逻辑 辅助 Apis 模块实现 WebSocket 连接的管理，更详细的功能不再描述，可以自行查看源码。 Manager 模块实现逻辑 定义了一些 Bitshares 链上的一些属性配置，我目前对 Bitshares 系统的其他细节还不了解，就不作解读说明了，等以后学习了更多的知识，再补充这些内容供大家参考。 总结 bitsharesjs-ws 针对 Bitshares 系统，定义了一套 API 调用的流程，并拓展了 WebSocket 的功能来维持一个稳定的连接通道，让外部系统能够专心于业务 API 的开发，但在其模块职责领域上，还应该有很多的可拓展空间，在此感谢此模块开发者为我们提供了一个好用的工具库，并节省了我们宝贵的时间。","categories":[{"name":"Bitshares","slug":"Bitshares","permalink":"http://bts500.github.com/categories/Bitshares/"}],"tags":[{"name":"Bitshares-ws","slug":"Bitshares-ws","permalink":"http://bts500.github.com/tags/Bitshares-ws/"}],"keywords":[{"name":"Bitshares","slug":"Bitshares","permalink":"http://bts500.github.com/categories/Bitshares/"}]},{"title":"WebStorm 集成第三方 Terminal 工具 GitBash","slug":"WebStorm集成GitBash","date":"2018-03-01T05:40:57.000Z","updated":"2018-03-12T02:07:17.338Z","comments":true,"path":"2018/03/01/WebStorm集成GitBash/","link":"","permalink":"http://bts500.github.com/2018/03/01/WebStorm集成GitBash/","excerpt":"","text":"打开设置面板 File -&gt; Settings -&gt; Tools -&gt; Terminal，设置 Shell path 的路径为第三方 Terminal 路径即可。","categories":[{"name":"资源工具","slug":"资源工具","permalink":"http://bts500.github.com/categories/资源工具/"}],"tags":[{"name":"WebStorm","slug":"WebStorm","permalink":"http://bts500.github.com/tags/WebStorm/"}],"keywords":[{"name":"资源工具","slug":"资源工具","permalink":"http://bts500.github.com/categories/资源工具/"}]},{"title":"Bitshares 开发者系列（1）—— Api接口的访问方式","slug":"Bitshares 开发者系列（1）—— Api接口的访问方式","date":"2018-03-01T03:04:35.000Z","updated":"2018-03-12T02:35:13.532Z","comments":true,"path":"2018/03/01/Bitshares 开发者系列（1）—— Api接口的访问方式/","link":"","permalink":"http://bts500.github.com/2018/03/01/Bitshares 开发者系列（1）—— Api接口的访问方式/","excerpt":"","text":"官方接口访问库 GitHub : https://github.com/bitshares/bitsharesjs-ws在阅读源码之前，最好先浏览一遍 Bitshares 官方公开的开发文档，虽然文档中对开发细节描述的不是很清楚，但也能对系统的通讯方式有个详细的了解。 Graphene API 通讯方式 Bitshares 系统共支持两种 API 调用方式： WebSocket Calls - 长连接调用 Remote Procedure Calls - HTTP 方式调用 官方 GitHub 仓库提供的 GUI 钱包客户端 bitshares-ui 就是使用 WebSocket 方式通讯的，此钱包客户端是使用 React 开发的前端工程，然后使用 Electron 工具打包成了各平台可用的桌面客户端，这样做的优势在于，技术栈全部使用前端技术，可以做功能的一次性开发，然后使用相关的打包工具，进行跨平台的客户端打包，能够同时进行 Web 端和 桌面客户端 的开发。 关于 Bitshares 官方的 GitHub 账号开源的几个项目，作一下简要的介绍，其中，bitshares-ui 项目依赖 bitsharesjs , 而 bitsharesjs 又依赖 bitsharesjs-ws 项目，它们之间的职责关系如下： bitshares-ui 完整的钱包客户端项目，使用 React + Electron 技术栈，同时支持 Web 和 桌面客户端的打包。 bitsharesjs API业务工具，基层依赖 bitsharesjs-ws 项目进行API通讯，其模块内部封装并完成了大部分的业务API。 bitsharesjs-ws 针对 Graphene 系统定制的 WebSocket 接口访问通信工具，封装并定制了系统特有的API访问流程。 WebSocket 调用 API 数据结构 12345678910&#123; \"id\" : 1, // 调用标识 \"method\" : \"call\", \"params\" : // 格式必须严格按照如下顺序传递 [ 0, // API类型标识符 \"get_accounts\", // 接口名称 [[\"1.2.0\"]] // 接口参数列表 ]&#125; id 字段的作用是专门针对 WebSocket 方式的 API 定制的，我们知道 WebSocket 是长连接协议，像 Socket 编程一样，可以发送二进制和文本类型的数据。但是发送数据和返回数据之间是无序的，你可能发送的顺序是 A-api、B-api ，然而服务器端响应给你的顺序却可能是 B-result、A-result。所以 API 在设计的时候特限定了一个 id 字段，当你发起 API 调用的时候指定一个唯一 id ，那么在响应结果里面，会把这个 id 再返回给你，你就可以根据这个 id 来区别响应结果应该怎么处理。 另外需要注意的就是 params 字段，此字段是一个数组类型，第一个元素代表 API 标识符，第二个元素代表要调用的 API 名称，第三个元素同样是一个数组类型，其数组中的每一个元素都将作为 API 的一个参数传递，并且应该注意参数的顺序与格式。 API 调用流程 Bitshares 系统的完整客户端节点提供了一系列可以通过 WebSocket 方式访问的API，但根据官方文档中描述的API调用流程，应该首先有一个初始化的调用过程： 1.首先应该登录到完整节点 :1&#123;\"id\":0, \"method\":\"call\", \"params\":[1, \"login\", [\"\",\"\"]]&#125; 2.然后获取指定类型的API标识 : 12345// 你可以动态的修改 “database” 属性，来获取不同的 API 类型请求标识。&#123;\"id\":0, \"method\":\"call\", \"params\":[1, \"database\", []]&#125;// 此次请求调用返回结果里面的 \"result\" 值，就是 \"database\" 类型 API 的标识符。 &#123;\"id\":2, \"result\":2&#125; 3.你可以多次的进行第二步操作，拿到不同类型的 API 标识符，最后只需要之前介绍过的 API 数据结构指定好 id 与 params 参数格式，即可调用所有公开的 API 接口。 API 返回结果数据格式 调用成功 JSON 格式 :1234&#123; \"id\" : 1, // 调用 API 时传递的调用标识。 \"result\" : ...data...&#125; 调用失败 JSON 格式 :123456789101112&#123; \"id\" : 0, // 调用 API 时传递的调用标识。 \"data\" : &#123; \"code\" : 1, \"error\" : &#123; \"code\" : error-code, \"name\" : \" .. name of exception ..\" \"message\" : \" .. message of exception ..\", \"stack\" : [ .. stack trace .. ], &#125;, &#125;,&#125; API 是否调用成功，可以简单的通过判断结果是否包含 resutl 字段来区分，假如包含 result 字段就可以认为调用成功，不同 API 有不同的 result 结构，届时根据 API 文档，分别进行解析处理即可。","categories":[{"name":"Bitshares","slug":"Bitshares","permalink":"http://bts500.github.com/categories/Bitshares/"}],"tags":[{"name":"Bitshares-ws","slug":"Bitshares-ws","permalink":"http://bts500.github.com/tags/Bitshares-ws/"}],"keywords":[{"name":"Bitshares","slug":"Bitshares","permalink":"http://bts500.github.com/categories/Bitshares/"}]},{"title":"WebStorm 快捷键大全","slug":"WebStorm-快捷键大全","date":"2018-03-01T01:45:57.000Z","updated":"2018-03-01T05:56:42.827Z","comments":false,"path":"2018/03/01/WebStorm-快捷键大全/","link":"","permalink":"http://bts500.github.com/2018/03/01/WebStorm-快捷键大全/","excerpt":"","text":"WebStorm 作为最好用的前端IDE工具之一，一些常用的快捷键掌握并记忆下来，能有效的提高工作效率，故记录此文档，以便日后工作时常查阅。 编辑文件内容类型快捷键 【Ctrl + Space 】基本代码完成 （任何类、 方法或变量名称）【Alt + Enter】 展示意图动作和快速修复【Ctrl + P】显示调用方法内参数信息【Ctrl + Q】 快速记录查找【Ctrl + mouse】放在代码上面-显示简短的代码信息【Ctrl + F1】在插入符号显示错误或警告的说明【Alt + Insert】生成代码【Ctrl + Alt + T】快速生成（if..else, try..catch, for, etc.）等【Ctrl + J】插入Live模板【Ctrl + / 】行注释与取消行注释【Ctrl + Shift + / 】块注释与取消块注释【Ctrl + W 】增加选择中代码块【Ctrl + Shift + W 】减少当前所选内容代码块【Alt + Q 】上下文信息【Ctrl + Alt + L 】格式化代码【Ctrl + Alt + I 】自动缩进的行数【Tab / Shift + Tab 】缩进/取消缩进选定的行【Ctrl + X , Shift + Delete】 剪切到剪贴板的当前行或者所选代码块【Ctrl + C】Ctrl + 插入复制当前行或者所选代码块到剪贴板【Ctrl + V】Shift + 从剪贴板插入粘贴【Ctrl + Shift + V 】最近缓冲区粘贴【Ctrl + D】复制当前行或者所选代码块【Ctrl + Y】删除行【Ctrl + Shift + J 】加入行【Ctrl + enter 】拆分行【shift + Enter 】 重新开始一行（无论光标在哪个位置）【Ctrl + Shift + U 】切换选中词或所选代码块的大小写【Ctrl + Shift +]】选中直到代码块的开始【Ctrl + Shift +[】选择直到代码块的结束【Ctrl + Delete】 删除光标右侧的词【Ctrl + backspace】 删除光标左侧的词【Ctrl + NumPad+】展开代码块【Ctrl + NumPad-】折叠代码块【Ctrl + Shift + NumPad+】展开所有代码块【Ctrl + Shift + NumPad-】折叠所有代码块【Ctrl + F4 】关闭当前标签页 同时编辑多行内容快捷键 【Alt + Click】 同时选中多行，同时编辑【Shift + Ctrl + Alt + J】选择所有当前选中的词【Alt + J】选择下一个相同的词【Alt + Shift + J】取消所有选中的词【Esc】取消选择所有选中的词或插入符号 搜索替换类型快捷键 【Ctrl + F】 查找【F3】 查找下一个【Shift + F3】 查找上一个【Ctrl + R】替换【Ctrl + Shift + F】 在路径中找到【Ctrl + Shift + R】 替换路径中的查找【Alt + f7】查找实例【Ctrl + f7】在文件中查找实例【Ctrl + Shift + f7】 在文件中高亮实例【Ctrl + Alt + F7】显示实例 导航类型快捷键 【Ctrl + N】跳转到指定类【Ctrl + Shift + N】 通过文件名快速查找工程内的文件【Ctrl + Alt + Shift + N】 通过一个字符查找函数位置【Alt + Right】进入下一个编辑器选项【Alt + Left】进入上一个编辑器选项【f12】 进入上一个工具窗口【esc】 从工具窗口进入编辑器【Shift + Esc】 隐藏活动窗口【Ctrl + Shift + F4】 关闭活动运行/消息/查找/选项卡【Ctrl + G】 跳转到指定行【Ctrl + E】 弹出最近打开的文件列表【Ctrl + Alt + Left】导航前进【Ctrl + Alt + Right】导航回退【Ctrl + Shift +Backspace】定位到最近编辑窗口【Alt + F1】查找当前选中的代码或文件在其他界面模块的位置【Ctrl + B/Click】跳转到定义处【Ctrl + 单击】转到声明【Ctrl + Alt + B 】跳转方法实现处【Ctrl + Shift + I】打开定义快速查找【Ctrl + Shift + B 】跳转方法定义处【Ctrl + U 】转到超级方法/超级类【Alt + Up/Down】在方法间快速移动定位【Ctrl +]/[】移动到代码块结束/启动【Ctrl + f12】弹出文件结构【Ctrl + H 】类型层次结构【Ctrl + Alt + H】 调用层次结构【F2/Shift + F2】跳转到后一个/前一个错误，在出错的语句之间进行跳转。【F4/Ctrl + Enter】 编辑源代码/查看源代码【Alt + home】 显示导航栏【F11】切换标记【Ctrl + F11】 采用记忆切换标记【Ctrl + #[0-9]】跳转到带编号的标记【Shift + F11 显示书签 运行类型快捷键 【Alt + Shift + F10/F9】 选择配置和运行/调试【Shift + F10/F9】 运行/调试【Ctrl + Shift + F10/F9】 运行/调试上下文配置从编辑器【Alt + Shift + R】 重新运行测试 调试类型快捷键 【F8】不进入函数【F7】 单步执行【Shift + F7】 只能单步执行【Shift + F8】跳出【Alt + F9】 运行到光标处【Alt + F8】 计算表达式的值【F9】 重新开始【Ctrl + f8】 切换断点【Ctrl + Shift + F8】 查看断点 VCS 版本控制类型快捷键 【Alt + 反引号 (‘)】 ‘VCS’ 快速弹出【Ctrl + K】提交项目到VCS【Ctrl + T】 从VCS更新项目【Alt + Shift + C】查看最近的更改 重构类型快捷键 【F5】拷贝当前文件【F6】移动当前文件【Alt + delete】 安全删除【Shift + F6】 重命名【Ctrl + Alt + N】嵌入变量【Ctrl + Alt + M】提取函数【Ctrl + Alt + V】引入变量【Ctrl + Alt + C】引入常量【Ctrl + Alt + P】引入参数【Ctrl + F6】改变方法名 常规类型快捷键 【Ctrl + Shift +a】 查找当前【双击shift】查找所有的（包括文件、命令等）【Alt + #[0-9]】 打开相应的工具窗口【Ctrl + Shift + f12】 键切换最大化编辑器【Alt + Shift + F】 将添加到收藏夹【Alt + Shift + I】 检查当前文件与当前配置文件【Ctrl + 反引号 (‘)】快速切换当前计划【Ctrl + Alt + S】 打开设置【Ctrl + Tab】 切换选项卡和工具窗口","categories":[{"name":"资源工具","slug":"资源工具","permalink":"http://bts500.github.com/categories/资源工具/"}],"tags":[{"name":"WebStorm","slug":"WebStorm","permalink":"http://bts500.github.com/tags/WebStorm/"}],"keywords":[{"name":"资源工具","slug":"资源工具","permalink":"http://bts500.github.com/categories/资源工具/"}]},{"title":"关于博客 - BTS500","slug":"关于博客","date":"2018-02-28T06:35:24.220Z","updated":"2018-03-01T05:39:38.114Z","comments":false,"path":"2018/02/28/关于博客/","link":"","permalink":"http://bts500.github.com/2018/02/28/关于博客/","excerpt":"","text":"我个人是一位长期的IT技术学习者，对软件开发有很浓厚的兴趣与爱好，虽然目前技术能力有限，但也学习和了解过很多的开发技术，很早就想建立一个自己的博客，把技术学习的过程和经验记录下来与自己分享，折腾了两天也终于把博客正式上线了，希望以后自己能更加努力，不忘初心。 此博客完全使用目前流行的前端技术构建，使用 Hexo 工具建立在 Github 平台之上，以后会记录一些我个人在技术学习的过程中，遇到的一些疑难杂症和解决方法，希望有缘看到的朋友多多指正交流。 另外一个建立此博客的原因，目前正在学习一个区块链项目（比特股） —— Bitshares 的应用层开发，在学习的过程中发现，此区块链项目的官方文档非常的简陋与残缺，并不能让第三方的技术人员作为参考资料进行基于 Bitshares 的项目开发。 因为 Bitshares 项目内部的有很多的属性和复杂的交易流程，然而在官方文档上并没有详细介绍和流程描述，只是简单的列出了一些不完整的API列表，所以我有想法在我个人学习的过程中，总结出来一些非官方资料来给其他人参考，也作为我自己的学习笔记使用。 在技术的学习途中，也希望能够结交到一些对 Bitshares 项目同样有兴趣的朋友，一起交流学习经验并整理资料，有想法的可以加QQ群：146302588。","categories":[{"name":"关于博客","slug":"关于博客","permalink":"http://bts500.github.com/categories/关于博客/"}],"tags":[{"name":"关于博客","slug":"关于博客","permalink":"http://bts500.github.com/tags/关于博客/"}],"keywords":[{"name":"关于博客","slug":"关于博客","permalink":"http://bts500.github.com/categories/关于博客/"}]}]}